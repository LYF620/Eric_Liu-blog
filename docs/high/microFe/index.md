# 微前端的背景

2016 年被提出，旨在解决将某个单⼀的单体应⽤，转化为多个可以独⽴运⾏、独⽴开发、独⽴部署、独⽴维护的服务或者应⽤的聚合，从⽽满⾜业务快速变化及分布式多团队并⾏开发的需求。

> 设计系统的组织，其产⽣的设计和架构等价于组织间的沟通结构；
>
> —— 康威定律(Conway’s Law)

# 微前端是什么

⼀种类似于微服务的架构，是⼀种由独⽴交付的多个前端应⽤组成整体的架构⻛格，将前端
应⽤分解成⼀些更⼩、更简单的能够独⽴开发、测试、部署的应⽤，⽽在⽤户看来仍然是内聚
的单个产品。

前端发展史
![前端发展史](/assets/microFe.png)

微前端架构
![微前端架构](/assets/microFeArc.jpg)

## 现代 Web 应用面临的问题：

- 多个系统在同一个仓库，不同子应用独立 SPA 模式
- 系统分为多个仓库，独立上线部署，采用 MPA 模式
- 性能体验
- 页面跳转和用户体验问题

## 微前端的特性：

- 低耦合
  - 当前的 web 应用多以 SPA 的形式，但随着不断迭代，SPA 的项目复杂度会越来越高，往往改一处而动全身，迭代发版成本也会对应的提升。微前端可以将庞大的应用拆分解体，解耦业务间的错综复杂关系，每个部分独立维护独立发版
- 不限制技术栈
  - 目前主要的开发模式在于协同开发，往往一个项目的不同需求需要开发者掌握相同的技术栈来进行开发，以及一些陈旧老项目的迭代，无法配合较新的技术开发，并且老项目的业务也需要复用。此时通过微前端，可以将这些问题系统整合，并行运行多套项目

## 微前端解决的问题：

- 业务代码不够独立，难以维护，不具有高复用性。
- 相同需求在不同的技术栈团队需要重新开发，导致已开发过的业务不断地消耗资源
- 支持快速迭代新的子业务
- 提升构建效率，发版效率，改善交付体验
- 支持架构渐进式升级

![前端发展史](/assets/microFeSpecial.jpg)

## 微前端为开发者提供了哪些能力？

- JS 沙箱
  - 子应用之间互不影响，包括全局变量、事件处理
- CSS 隔离
  - 子应用之间的样式互不影响，切换时装载和卸载
- HTML Entry
  - Config Entry 的进阶版，简化开发者使用，但把解析消耗留给了用户
- Config Entry：
  - 配置每个子应用的 JS 和 CSS，包括内联样式
- 按需加载
  - 切换到页面时才加载相应的 HTML、CSS 和 JS
- 公共依赖加载
  - 大部分子应用都用到的资源处理
- 预加载
  - 空闲时加载子应用资源，用户行为数据支持
- 父子应用通讯
  - 子应用父应用消息通知
- 子应用嵌套
- 子应用并行

## 一些实现微应用的方案：

1、HTTP 服务器路由重定向

2、在不同框架智商设计通讯、加载机制（qiankun、Single-icestark)

3、webpack5 ModuleFederation EMP

4、iframe + messageChannel

5、使用纯 Web Components 构建应用
![Web Components](/assets/webcomponent.jpg)

## QA

1、为什么不使用 iframe？

- iframe 可以完美的解决 JS 隔离、样式隔离。但其隔离性无法突破，应用间上下文无法被共享。
- url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用
- UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中.
- 全局上下文隔离，内存变量不同享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
- 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。
